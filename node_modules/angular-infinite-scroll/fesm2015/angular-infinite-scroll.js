import { NgForOf, CommonModule } from '@angular/common';
import { BehaviorSubject, interval, merge, Observable, Subject } from 'rxjs';
import { exhaustMap, switchMap, take } from 'rxjs/operators';
import { Component, Input, IterableDiffers, NgZone, ViewChild, ViewContainerRef, ContentChild, ContentChildren, Directive, TemplateRef, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULTS = {
    STEP: 4,
    POSITION: 0,
    OFFSET: 100,
    DELAY: 0
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template T
 */
class InfiniteScroll {
    /**
     * @param {?} _differs
     * @param {?} zone
     */
    constructor(_differs, zone) {
        this._differs = _differs;
        this.zone = zone;
        this._userEnd$ = new Observable();
        this._end$ = new Subject();
        this._updateAfterRender$ = new Subject();
        this.position = DEFAULTS.POSITION;
        this.step = DEFAULTS.STEP;
        this.offset = DEFAULTS.OFFSET;
        this.delay = DEFAULTS.DELAY;
        this.loading$ = new BehaviorSubject(false);
        zone.runOutsideAngular(() => {
            window.addEventListener('scroll', () => this._update());
            window.addEventListener('resize', () => this._update());
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._subscriptionLoadingEnd = merge(this._userEnd$, this._updateAfterRender$).subscribe(() => this.loading$.next(false));
        this._subscriptionUpdateAfterRender =
            this._updateAfterRender$.pipe(switchMap(() => interval(this.delay).pipe(take(1)))).subscribe(() => this._update());
        this._update();
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this._ngFor) {
            this._ngFor.ngDoCheck();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy(this._subscriptionEnd);
        this.destroy(this._subscriptionLoading);
        this.destroy(this._subscriptionLoadingEnd);
        this.destroy(this._subscriptionUpdateAfterRender);
    }
    /**
     * @param {?} viewContainer
     * @param {?} template
     * @return {?}
     */
    createNgFor(viewContainer, template) {
        this._ngFor = new NgForOf(viewContainer, template, this._differs);
    }
    /**
     * @param {?} loading
     * @return {?}
     */
    subscribeLoading(loading) {
        this.destroy(this._subscriptionLoading);
        this._subscriptionLoading = this.loading$.subscribe(loading);
    }
    /**
     * @param {?} scrollEnd
     * @return {?}
     */
    subscribeEnd(scrollEnd) {
        this.destroy(this._subscriptionEnd);
        this._userEnd$ = this._end$.pipe(exhaustMap(() => scrollEnd(this.position, this.step)));
        this._subscriptionEnd = this._userEnd$.subscribe(this.newItems.bind(this), () => this.newItems.bind(this)([]));
    }
    /**
     * @return {?}
     */
    _update() {
        /** @type {?} */
        const scrollHeight = window.innerHeight + window.scrollY;
        if (scrollHeight >= document.body.offsetHeight - this.offset) {
            this.zone.runOutsideAngular(() => {
                this.update();
            });
        }
    }
    /**
     * @param {?} subscription
     * @return {?}
     */
    destroy(subscription) {
        if (subscription && !subscription.closed) {
            subscription.unsubscribe();
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class InfiniteStaticMarker {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
        this.enabled = false;
    }
}
InfiniteStaticMarker.decorators = [
    { type: Directive, args: [{ selector: '[infiniteStatic]' },] },
];
/** @nocollapse */
InfiniteStaticMarker.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * @template T
 */
class InfiniteTemplateMarker {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
InfiniteTemplateMarker.decorators = [
    { type: Directive, args: [{ selector: '[infiniteTemplate]' },] },
];
/** @nocollapse */
InfiniteTemplateMarker.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * @template T
 */
class InfiniteScrollComponent extends InfiniteScroll {
    /**
     * @param {?} differs
     * @param {?} zone
     */
    constructor(differs, zone) {
        super(differs, zone);
        this._dummies = 0;
        this._outOfItems = false;
    }
    /**
     * @param {?} loading
     * @return {?}
     */
    set loading(loading) {
        this.subscribeLoading(loading);
    }
    /**
     * @param {?} scrollEnd
     * @return {?}
     */
    set end(scrollEnd) {
        this.subscribeEnd(scrollEnd);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._itemsStatic = this.staticMarkers.toArray();
        this.updateItems();
        this.update();
    }
    /**
     * @return {?}
     */
    update() {
        if (!this._items) {
            this._items = [];
            this._dummies = 0;
        }
        if (this._items && (!this._items.length || this._items.every((item) => item === undefined))) {
            this._items = [];
            this._dummies = 0;
            this.addDummies();
        }
        /** @type {?} */
        let staticLength = 0;
        if (this._itemsStatic) {
            staticLength = this._itemsStatic.length;
        }
        if (this.position < staticLength) {
            this.loading$.next(true);
            this._updateAfterRender$.next();
            this.updateItems();
            this.position += this.step;
        }
        else if (staticLength + this.position < this._items.length - this._dummies) {
            this.loading$.next(true);
            this._updateAfterRender$.next();
            this.position += this.step;
        }
        else if (this._subscriptionEnd) {
            this.loading$.next(true);
            this._end$.next();
            this.addDummies();
            this.position += this.step;
        }
    }
    /**
     * @param {?} newItems
     * @return {?}
     */
    newItems(newItems) {
        while (this._dummies > 0) {
            if (this._items.length) {
                this._items.pop();
            }
            this._dummies--;
        }
        /** @type {?} */
        const newItemsArray = Array.from(newItems);
        this.zone.run(() => {
            this._items = this._items.concat(newItemsArray);
        });
        // only continue when newItems arrive
        if (newItemsArray.length) {
            this._updateAfterRender$.next();
        }
        else {
            this._outOfItems = true;
        }
    }
    /**
     * @return {?}
     */
    updateItems() {
        this.zone.run(() => {
            for (const index in this._itemsStatic) {
                this._itemsStatic[index].enabled = this.position > index;
            }
        });
    }
    /**
     * @return {?}
     */
    addDummies() {
        this.zone.run(() => {
            if (!this._dummies && !this._outOfItems) {
                this._items = this._items.concat(Array(this.step).fill(undefined));
                this._dummies += this.step;
            }
        });
    }
}
InfiniteScrollComponent.decorators = [
    { type: Component, args: [{
                selector: 'infinite-scroll',
                template: `
    <ng-template ngFor let-item [ngForOf]="_itemsStatic">
      <ng-template [ngIf]="item.enabled">
        <ng-container *ngTemplateOutlet="item.template"></ng-container>
      </ng-template>
    </ng-template>
    <ng-template ngFor let-item [ngForOf]="_items">
      <ng-container *ngTemplateOutlet="templateMarker.template; context: {$implicit: item}"></ng-container>
    </ng-template>`
            },] },
];
/** @nocollapse */
InfiniteScrollComponent.ctorParameters = () => [
    { type: IterableDiffers },
    { type: NgZone }
];
InfiniteScrollComponent.propDecorators = {
    staticMarkers: [{ type: ContentChildren, args: [InfiniteStaticMarker,] }],
    templateMarker: [{ type: ContentChild, args: [InfiniteTemplateMarker,] }],
    dynamicTemplate: [{ type: ViewChild, args: ['dynamic',] }],
    position: [{ type: Input }],
    step: [{ type: Input }],
    offset: [{ type: Input }],
    delay: [{ type: Input }],
    loading: [{ type: Input }],
    end: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class InfiniteScrollDirective extends InfiniteScroll {
    /**
     * @param {?} viewContainer
     * @param {?} templateRef
     * @param {?} differs
     * @param {?} zone
     */
    constructor(viewContainer, templateRef, differs, zone) {
        super(differs, zone);
        this._positionInitial = DEFAULTS.POSITION;
        this._dummies = 0;
        this._outOfItems = false;
        this.step = DEFAULTS.STEP;
        this.offset = DEFAULTS.OFFSET;
        this.delay = DEFAULTS.DELAY;
        this.createNgFor(viewContainer, templateRef);
    }
    /**
     * @param {?} infiniteScrollOf
     * @return {?}
     */
    set infiniteScrollOf(infiniteScrollOf) {
        if (infiniteScrollOf) {
            this._items = Array.from(infiniteScrollOf);
        }
        this.position = this._positionInitial;
        this._dummies = 0;
        this.updateItems();
        this.update();
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    set infiniteScrollTrackBy(fn) {
        this._ngFor.ngForTrackBy = fn;
    }
    /**
     * @return {?}
     */
    get infiniteScrollTrackBy() {
        return this._ngFor.ngForTrackBy;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set infiniteScrollTemplate(value) {
        this._ngFor.ngForTemplate = value;
    }
    /**
     * @param {?} position
     * @return {?}
     */
    set infiniteScrollPosition(position) {
        if (position === undefined || position === null) {
            this.position = DEFAULTS.POSITION;
        }
        else {
            this.position = position;
        }
        this._positionInitial = position;
    }
    /**
     * @param {?} loading
     * @return {?}
     */
    set infiniteScrollLoading(loading) {
        this.subscribeLoading(loading);
    }
    /**
     * @param {?} scrollEnd
     * @return {?}
     */
    set infiniteScrollEnd(scrollEnd) {
        this.subscribeEnd(scrollEnd);
    }
    /**
     * @return {?}
     */
    update() {
        if (!this._items) {
            this._items = [];
        }
        if (this._items && (!this._items.length || this._items.every((item) => item === undefined))) {
            this._items = [];
            this.addDummies();
            this.updateItems();
        }
        if (this.position < this._items.length - this._dummies) {
            this.loading$.next(true);
            this.updateItems();
            this._updateAfterRender$.next();
            this.position += this.step;
        }
        else if (this._subscriptionEnd) {
            this.loading$.next(true);
            this._end$.next();
            this.position += this.step;
            this.addDummies();
            this.updateItems();
        }
    }
    /**
     * @param {?} newItems
     * @return {?}
     */
    newItems(newItems) {
        while (this._dummies > 0) {
            if (this._items.length) {
                this._items.pop();
            }
            this._dummies--;
        }
        /** @type {?} */
        const newItemsArray = Array.from(newItems);
        this._items = this._items.concat(newItemsArray);
        this.updateItems();
        // only continue when newItems arrive
        if (newItemsArray.length) {
            this._updateAfterRender$.next();
        }
        else {
            this._outOfItems = true;
        }
    }
    /**
     * @return {?}
     */
    updateItems() {
        this.zone.run(() => {
            if (this._items) {
                // update ngForOf<T> directive
                this._ngFor.ngForOf = this._items.slice(0, this.position);
            }
        });
    }
    /**
     * @return {?}
     */
    addDummies() {
        if (!this._dummies && !this._outOfItems) {
            this._items = this._items.concat(Array(this.step).fill(undefined));
            this._dummies += this.step;
        }
    }
}
InfiniteScrollDirective.decorators = [
    { type: Directive, args: [{ selector: '[infiniteScroll]' },] },
];
/** @nocollapse */
InfiniteScrollDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: TemplateRef },
    { type: IterableDiffers },
    { type: NgZone }
];
InfiniteScrollDirective.propDecorators = {
    infiniteScrollOf: [{ type: Input }],
    infiniteScrollTrackBy: [{ type: Input }],
    infiniteScrollTemplate: [{ type: Input }],
    infiniteScrollPosition: [{ type: Input }],
    step: [{ type: Input, args: ['infiniteScrollStep',] }],
    offset: [{ type: Input, args: ['infiniteScrollOffset',] }],
    delay: [{ type: Input, args: ['infiniteScrollDelay',] }],
    infiniteScrollLoading: [{ type: Input }],
    infiniteScrollEnd: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class InfiniteScrollModule {
}
InfiniteScrollModule.decorators = [
    { type: NgModule, args: [{
                declarations: [InfiniteScrollDirective, InfiniteScrollComponent, InfiniteStaticMarker, InfiniteTemplateMarker],
                imports: [CommonModule],
                exports: [InfiniteScrollDirective, InfiniteScrollComponent, InfiniteStaticMarker, InfiniteTemplateMarker]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { InfiniteScrollModule, InfiniteScroll as ɵb, InfiniteScrollComponent as ɵe, InfiniteStaticMarker as ɵc, InfiniteTemplateMarker as ɵd, InfiniteScrollDirective as ɵa };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1pbmZpbml0ZS1zY3JvbGwuanMubWFwIiwic291cmNlcyI6WyJuZzovL2FuZ3VsYXItaW5maW5pdGUtc2Nyb2xsL2xpYi9kZWZhdWx0cy50cyIsIm5nOi8vYW5ndWxhci1pbmZpbml0ZS1zY3JvbGwvbGliL2luZmluaXRlLXNjcm9sbC50cyIsIm5nOi8vYW5ndWxhci1pbmZpbml0ZS1zY3JvbGwvbGliL2luZmluaXRlLXNjcm9sbC5jb21wb25lbnQudHMiLCJuZzovL2FuZ3VsYXItaW5maW5pdGUtc2Nyb2xsL2xpYi9pbmZpbml0ZS1zY3JvbGwuZGlyZWN0aXZlLnRzIiwibmc6Ly9hbmd1bGFyLWluZmluaXRlLXNjcm9sbC9saWIvaW5maW5pdGUtc2Nyb2xsLm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgREVGQVVMVFMgPSB7XHJcbiAgU1RFUDogNCxcclxuICBQT1NJVElPTjogMCxcclxuICBPRkZTRVQ6IDEwMCxcclxuICBERUxBWTogMFxyXG59OyIsImltcG9ydCB7TmdGb3JPZiwgTmdGb3JPZkNvbnRleHR9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7RG9DaGVjaywgSXRlcmFibGVEaWZmZXJzLCBOZ0l0ZXJhYmxlLCBOZ1pvbmUsIE9uRGVzdHJveSwgT25Jbml0LCBUZW1wbGF0ZVJlZiwgVmlld0NvbnRhaW5lclJlZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7QmVoYXZpb3JTdWJqZWN0LCBpbnRlcnZhbCwgbWVyZ2UsIE9ic2VydmFibGUsIFN1YmplY3QsIFN1YnNjcmlwdGlvbn0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7ZXhoYXVzdE1hcCwgc3dpdGNoTWFwLCB0YWtlfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQge0RFRkFVTFRTfSBmcm9tICcuL2RlZmF1bHRzJztcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJbmZpbml0ZVNjcm9sbDxUPiBpbXBsZW1lbnRzIE9uSW5pdCwgRG9DaGVjaywgT25EZXN0cm95IHtcclxuICBwcml2YXRlIF9zdWJzY3JpcHRpb25Mb2FkaW5nOiBTdWJzY3JpcHRpb247XHJcbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uTG9hZGluZ0VuZDogU3Vic2NyaXB0aW9uO1xyXG4gIHByaXZhdGUgX3VzZXJFbmQkID0gbmV3IE9ic2VydmFibGU8TmdJdGVyYWJsZTxUPj4oKTtcclxuXHJcbiAgcHJvdGVjdGVkIF9zdWJzY3JpcHRpb25FbmQ6IFN1YnNjcmlwdGlvbjtcclxuICBwcm90ZWN0ZWQgX3N1YnNjcmlwdGlvblVwZGF0ZUFmdGVyUmVuZGVyOiBTdWJzY3JpcHRpb247XHJcblxyXG4gIHByb3RlY3RlZCBfZW5kJCA9IG5ldyBTdWJqZWN0PE5nSXRlcmFibGU8VD4+KCk7XHJcbiAgcHJvdGVjdGVkIF91cGRhdGVBZnRlclJlbmRlciQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XHJcblxyXG4gIHByb3RlY3RlZCBfbmdGb3I7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2RpZmZlcnM6IEl0ZXJhYmxlRGlmZmVycywgcHVibGljIHpvbmU6IE5nWm9uZSkge1xyXG4gICAgem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCAoKSA9PiB0aGlzLl91cGRhdGUoKSk7XHJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKSA9PiB0aGlzLl91cGRhdGUoKSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHBvc2l0aW9uID0gREVGQVVMVFMuUE9TSVRJT047XHJcbiAgc3RlcCA9IERFRkFVTFRTLlNURVA7XHJcbiAgb2Zmc2V0ID0gREVGQVVMVFMuT0ZGU0VUO1xyXG4gIGRlbGF5ID0gREVGQVVMVFMuREVMQVk7XHJcbiAgbG9hZGluZyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcclxuXHJcbiAgbmdPbkluaXQoKSB7XHJcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25Mb2FkaW5nRW5kID0gbWVyZ2UodGhpcy5fdXNlckVuZCQsIHRoaXMuX3VwZGF0ZUFmdGVyUmVuZGVyJCkuc3Vic2NyaWJlKCgpID0+IHRoaXMubG9hZGluZyQubmV4dChmYWxzZSkpO1xyXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uVXBkYXRlQWZ0ZXJSZW5kZXIgPVxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUFmdGVyUmVuZGVyJC5waXBlKHN3aXRjaE1hcCgoKSA9PiBpbnRlcnZhbCh0aGlzLmRlbGF5KS5waXBlKHRha2UoMSkpKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3VwZGF0ZSgpKTtcclxuXHJcbiAgICB0aGlzLl91cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIG5nRG9DaGVjaygpIHtcclxuICAgIGlmICh0aGlzLl9uZ0Zvcikge1xyXG4gICAgICB0aGlzLl9uZ0Zvci5uZ0RvQ2hlY2soKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCkge1xyXG4gICAgdGhpcy5kZXN0cm95KHRoaXMuX3N1YnNjcmlwdGlvbkVuZCk7XHJcbiAgICB0aGlzLmRlc3Ryb3kodGhpcy5fc3Vic2NyaXB0aW9uTG9hZGluZyk7XHJcbiAgICB0aGlzLmRlc3Ryb3kodGhpcy5fc3Vic2NyaXB0aW9uTG9hZGluZ0VuZCk7XHJcbiAgICB0aGlzLmRlc3Ryb3kodGhpcy5fc3Vic2NyaXB0aW9uVXBkYXRlQWZ0ZXJSZW5kZXIpO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIGNyZWF0ZU5nRm9yKHZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxOZ0Zvck9mQ29udGV4dDxUPj4pIHtcclxuICAgIHRoaXMuX25nRm9yID0gbmV3IE5nRm9yT2Y8VD4odmlld0NvbnRhaW5lciwgdGVtcGxhdGUsIHRoaXMuX2RpZmZlcnMpO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIHN1YnNjcmliZUxvYWRpbmcobG9hZGluZzogKGxvYWRpbmc6IGJvb2xlYW4pID0+IHZvaWQpIHtcclxuICAgIHRoaXMuZGVzdHJveSh0aGlzLl9zdWJzY3JpcHRpb25Mb2FkaW5nKTtcclxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkxvYWRpbmcgPSB0aGlzLmxvYWRpbmckLnN1YnNjcmliZShsb2FkaW5nKTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBzdWJzY3JpYmVFbmQoc2Nyb2xsRW5kOiAocG9zaXRpb246IG51bWJlciwgaW50ZXJ2YWw6IG51bWJlcikgPT4gT2JzZXJ2YWJsZTxOZ0l0ZXJhYmxlPFQ+Pikge1xyXG4gICAgdGhpcy5kZXN0cm95KHRoaXMuX3N1YnNjcmlwdGlvbkVuZCk7XHJcbiAgICB0aGlzLl91c2VyRW5kJCA9IHRoaXMuX2VuZCQucGlwZShleGhhdXN0TWFwKCgpID0+IHNjcm9sbEVuZCh0aGlzLnBvc2l0aW9uLCB0aGlzLnN0ZXApKSk7XHJcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25FbmQgPSB0aGlzLl91c2VyRW5kJC5zdWJzY3JpYmUodGhpcy5uZXdJdGVtcy5iaW5kKHRoaXMpLCAoKSA9PiB0aGlzLm5ld0l0ZW1zLmJpbmQodGhpcykoW10pKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX3VwZGF0ZSgpIHtcclxuICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCArIHdpbmRvdy5zY3JvbGxZO1xyXG4gICAgaWYgKHNjcm9sbEhlaWdodCA+PSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodCAtIHRoaXMub2Zmc2V0KSB7XHJcbiAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGRlc3Ryb3koc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24pIHtcclxuICAgIGlmIChzdWJzY3JpcHRpb24gJiYgIXN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcclxuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgdXBkYXRlKCk7XHJcblxyXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBuZXdJdGVtcyhuZXdJdGVtczogTmdJdGVyYWJsZTxUPik7XHJcbn1cclxuIiwiaW1wb3J0IHtOZ0Zvck9mQ29udGV4dH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHtBZnRlckNvbnRlbnRJbml0LCBDb21wb25lbnQsIElucHV0LCBJdGVyYWJsZURpZmZlcnMsIE5nSXRlcmFibGUsIE5nWm9uZSwgVmlld0NoaWxkLCBWaWV3Q29udGFpbmVyUmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHtDb250ZW50Q2hpbGQsIENvbnRlbnRDaGlsZHJlbiwgRGlyZWN0aXZlLCBRdWVyeUxpc3QsIFRlbXBsYXRlUmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzJztcclxuXHJcbmltcG9ydCB7SW5maW5pdGVTY3JvbGx9IGZyb20gJy4vaW5maW5pdGUtc2Nyb2xsJztcclxuXHJcbkBEaXJlY3RpdmUoe3NlbGVjdG9yOiAnW2luZmluaXRlU3RhdGljXSd9KVxyXG5leHBvcnQgY2xhc3MgSW5maW5pdGVTdGF0aWNNYXJrZXI8VD4ge1xyXG4gIHB1YmxpYyBlbmFibGVkID0gZmFsc2U7XHJcbiAgY29uc3RydWN0b3IocHVibGljIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxUPikge31cclxufVxyXG5cclxuQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdbaW5maW5pdGVUZW1wbGF0ZV0nfSlcclxuZXhwb3J0IGNsYXNzIEluZmluaXRlVGVtcGxhdGVNYXJrZXI8VD4ge1xyXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8TmdGb3JPZkNvbnRleHQ8VD4+KSB7fVxyXG59XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ2luZmluaXRlLXNjcm9sbCcsXHJcbiAgdGVtcGxhdGU6IGBcclxuICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtaXRlbSBbbmdGb3JPZl09XCJfaXRlbXNTdGF0aWNcIj5cclxuICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIml0ZW0uZW5hYmxlZFwiPlxyXG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJpdGVtLnRlbXBsYXRlXCI+PC9uZy1jb250YWluZXI+XHJcbiAgICAgIDwvbmctdGVtcGxhdGU+XHJcbiAgICA8L25nLXRlbXBsYXRlPlxyXG4gICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1pdGVtIFtuZ0Zvck9mXT1cIl9pdGVtc1wiPlxyXG4gICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwidGVtcGxhdGVNYXJrZXIudGVtcGxhdGU7IGNvbnRleHQ6IHskaW1wbGljaXQ6IGl0ZW19XCI+PC9uZy1jb250YWluZXI+XHJcbiAgICA8L25nLXRlbXBsYXRlPmBcclxufSlcclxuZXhwb3J0IGNsYXNzIEluZmluaXRlU2Nyb2xsQ29tcG9uZW50PFQ+IGV4dGVuZHMgSW5maW5pdGVTY3JvbGw8VD4gaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcclxuICBAQ29udGVudENoaWxkcmVuKEluZmluaXRlU3RhdGljTWFya2VyKSBzdGF0aWNNYXJrZXJzOiBRdWVyeUxpc3Q8SW5maW5pdGVTdGF0aWNNYXJrZXI8VD4+O1xyXG4gIEBDb250ZW50Q2hpbGQoSW5maW5pdGVUZW1wbGF0ZU1hcmtlcikgdGVtcGxhdGVNYXJrZXI6IEluZmluaXRlVGVtcGxhdGVNYXJrZXI8VD47XHJcbiAgQFZpZXdDaGlsZCgnZHluYW1pYycpIGR5bmFtaWNUZW1wbGF0ZTogVmlld0NvbnRhaW5lclJlZjtcclxuXHJcbiAgX2l0ZW1zU3RhdGljOiBBcnJheTxJbmZpbml0ZVN0YXRpY01hcmtlcjxUPj47XHJcbiAgX2l0ZW1zOiBBcnJheTxUPjtcclxuXHJcbiAgcHJpdmF0ZSBfZHVtbWllcyA9IDA7XHJcbiAgcHJpdmF0ZSBfb3V0T2ZJdGVtcyA9IGZhbHNlO1xyXG5cclxuICBjb25zdHJ1Y3RvcihkaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMsIHpvbmU6IE5nWm9uZSkge1xyXG4gICAgc3VwZXIoZGlmZmVycywgem9uZSk7XHJcbiAgfVxyXG5cclxuICBASW5wdXQoKSBwb3NpdGlvbjtcclxuICBASW5wdXQoKSBzdGVwO1xyXG4gIEBJbnB1dCgpIG9mZnNldDtcclxuICBASW5wdXQoKSBkZWxheTtcclxuICBASW5wdXQoKVxyXG4gIHNldCBsb2FkaW5nKGxvYWRpbmc6IChsb2FkaW5nOiBib29sZWFuKSA9PiB2b2lkKSB7XHJcbiAgICB0aGlzLnN1YnNjcmliZUxvYWRpbmcobG9hZGluZyk7XHJcbiAgfVxyXG4gIEBJbnB1dCgpXHJcbiAgc2V0IGVuZChzY3JvbGxFbmQ6IChwb3NpdGlvbjogbnVtYmVyLCBpbnRlcnZhbDogbnVtYmVyKSA9PiBPYnNlcnZhYmxlPE5nSXRlcmFibGU8VD4+KSB7XHJcbiAgICB0aGlzLnN1YnNjcmliZUVuZChzY3JvbGxFbmQpO1xyXG4gIH1cclxuXHJcbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xyXG4gICAgdGhpcy5faXRlbXNTdGF0aWMgPSB0aGlzLnN0YXRpY01hcmtlcnMudG9BcnJheSgpO1xyXG4gICAgdGhpcy51cGRhdGVJdGVtcygpO1xyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCB1cGRhdGUoKSB7XHJcbiAgICBpZiAoIXRoaXMuX2l0ZW1zKSB7XHJcbiAgICAgIHRoaXMuX2l0ZW1zID0gW107XHJcbiAgICAgIHRoaXMuX2R1bW1pZXMgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9pdGVtcyAmJiAoIXRoaXMuX2l0ZW1zLmxlbmd0aCB8fCB0aGlzLl9pdGVtcy5ldmVyeSgoaXRlbSkgPT4gaXRlbSA9PT0gdW5kZWZpbmVkKSkpIHtcclxuICAgICAgdGhpcy5faXRlbXMgPSBbXTtcclxuICAgICAgdGhpcy5fZHVtbWllcyA9IDA7XHJcbiAgICAgIHRoaXMuYWRkRHVtbWllcygpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBzdGF0aWNMZW5ndGggPSAwO1xyXG4gICAgaWYgKHRoaXMuX2l0ZW1zU3RhdGljKSB7XHJcbiAgICAgIHN0YXRpY0xlbmd0aCA9IHRoaXMuX2l0ZW1zU3RhdGljLmxlbmd0aFxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLnBvc2l0aW9uIDwgc3RhdGljTGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMubG9hZGluZyQubmV4dCh0cnVlKTtcclxuICAgICAgdGhpcy5fdXBkYXRlQWZ0ZXJSZW5kZXIkLm5leHQoKTtcclxuICAgICAgdGhpcy51cGRhdGVJdGVtcygpO1xyXG4gICAgICB0aGlzLnBvc2l0aW9uICs9IHRoaXMuc3RlcDtcclxuICAgIH0gZWxzZSBpZiAoc3RhdGljTGVuZ3RoICsgdGhpcy5wb3NpdGlvbiA8IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIHRoaXMuX2R1bW1pZXMpIHtcclxuICAgICAgdGhpcy5sb2FkaW5nJC5uZXh0KHRydWUpO1xyXG4gICAgICB0aGlzLl91cGRhdGVBZnRlclJlbmRlciQubmV4dCgpO1xyXG4gICAgICB0aGlzLnBvc2l0aW9uICs9IHRoaXMuc3RlcDtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3Vic2NyaXB0aW9uRW5kKSB7XHJcbiAgICAgIHRoaXMubG9hZGluZyQubmV4dCh0cnVlKTtcclxuICAgICAgdGhpcy5fZW5kJC5uZXh0KCk7XHJcbiAgICAgIHRoaXMuYWRkRHVtbWllcygpO1xyXG4gICAgICB0aGlzLnBvc2l0aW9uICs9IHRoaXMuc3RlcDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBuZXdJdGVtcyhuZXdJdGVtczogTmdJdGVyYWJsZTxUPikge1xyXG4gICAgd2hpbGUgKHRoaXMuX2R1bW1pZXMgPiAwKSB7XHJcbiAgICAgIGlmICh0aGlzLl9pdGVtcy5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLl9pdGVtcy5wb3AoKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9kdW1taWVzLS07XHJcbiAgICB9XHJcbiAgICBjb25zdCBuZXdJdGVtc0FycmF5ID0gQXJyYXkuZnJvbShuZXdJdGVtcyk7XHJcbiAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcclxuICAgICAgdGhpcy5faXRlbXMgPSB0aGlzLl9pdGVtcy5jb25jYXQobmV3SXRlbXNBcnJheSk7XHJcbiAgICB9KTtcclxuICAgIC8vIG9ubHkgY29udGludWUgd2hlbiBuZXdJdGVtcyBhcnJpdmVcclxuICAgIGlmIChuZXdJdGVtc0FycmF5Lmxlbmd0aCkge1xyXG4gICAgICB0aGlzLl91cGRhdGVBZnRlclJlbmRlciQubmV4dCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fb3V0T2ZJdGVtcyA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHVwZGF0ZUl0ZW1zKCkge1xyXG4gICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgIGZvciAoY29uc3QgaW5kZXggaW4gdGhpcy5faXRlbXNTdGF0aWMpIHtcclxuICAgICAgICB0aGlzLl9pdGVtc1N0YXRpY1tpbmRleF0uZW5hYmxlZCA9IHRoaXMucG9zaXRpb24gPiBpbmRleDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFkZER1bW1pZXMoKSB7XHJcbiAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcclxuICAgICAgaWYgKCF0aGlzLl9kdW1taWVzICYmICF0aGlzLl9vdXRPZkl0ZW1zKSB7XHJcbiAgICAgICAgdGhpcy5faXRlbXMgPSB0aGlzLl9pdGVtcy5jb25jYXQoQXJyYXkodGhpcy5zdGVwKS5maWxsKHVuZGVmaW5lZCkpO1xyXG4gICAgICAgIHRoaXMuX2R1bW1pZXMgKz0gdGhpcy5zdGVwO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHtOZ0Zvck9mQ29udGV4dH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHtEaXJlY3RpdmUsIElucHV0LCBJdGVyYWJsZURpZmZlcnMsIE5nSXRlcmFibGUsIE9uRGVzdHJveSwgT25Jbml0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHtOZ1pvbmUsIFRlbXBsYXRlUmVmLCBUcmFja0J5RnVuY3Rpb24sIFZpZXdDb250YWluZXJSZWZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQge0RFRkFVTFRTfSBmcm9tICcuL2RlZmF1bHRzJztcclxuaW1wb3J0IHtJbmZpbml0ZVNjcm9sbH0gZnJvbSAnLi9pbmZpbml0ZS1zY3JvbGwnO1xyXG5cclxuQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdbaW5maW5pdGVTY3JvbGxdJ30pXHJcbmV4cG9ydCBjbGFzcyBJbmZpbml0ZVNjcm9sbERpcmVjdGl2ZTxUPiBleHRlbmRzIEluZmluaXRlU2Nyb2xsPFQ+IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xyXG4gIHByaXZhdGUgX2l0ZW1zOiBBcnJheTxUPjtcclxuICBwcml2YXRlIF9wb3NpdGlvbkluaXRpYWwgPSBERUZBVUxUUy5QT1NJVElPTjtcclxuXHJcbiAgcHJpdmF0ZSBfZHVtbWllcyA9IDA7XHJcbiAgcHJpdmF0ZSBfb3V0T2ZJdGVtcyA9IGZhbHNlO1xyXG5cclxuICBjb25zdHJ1Y3Rvcih2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLCB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8TmdGb3JPZkNvbnRleHQ8VD4+LCBkaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMsIHpvbmU6IE5nWm9uZSkge1xyXG4gICAgc3VwZXIoZGlmZmVycywgem9uZSk7XHJcbiAgICB0aGlzLmNyZWF0ZU5nRm9yKHZpZXdDb250YWluZXIsIHRlbXBsYXRlUmVmKTtcclxuICB9XHJcblxyXG4gIEBJbnB1dCgpXHJcbiAgc2V0IGluZmluaXRlU2Nyb2xsT2YoaW5maW5pdGVTY3JvbGxPZjogTmdJdGVyYWJsZTxUPikge1xyXG4gICAgaWYgKGluZmluaXRlU2Nyb2xsT2YpIHtcclxuICAgICAgdGhpcy5faXRlbXMgPSBBcnJheS5mcm9tKGluZmluaXRlU2Nyb2xsT2YpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uSW5pdGlhbDtcclxuICAgIHRoaXMuX2R1bW1pZXMgPSAwO1xyXG4gICAgdGhpcy51cGRhdGVJdGVtcygpO1xyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcbiAgQElucHV0KClcclxuICBzZXQgaW5maW5pdGVTY3JvbGxUcmFja0J5KGZuOiBUcmFja0J5RnVuY3Rpb248VD4pIHtcclxuICAgIHRoaXMuX25nRm9yLm5nRm9yVHJhY2tCeSA9IGZuO1xyXG4gIH1cclxuICBnZXQgaW5maW5pdGVTY3JvbGxUcmFja0J5KCk6IFRyYWNrQnlGdW5jdGlvbjxUPiB7XHJcbiAgICByZXR1cm4gdGhpcy5fbmdGb3IubmdGb3JUcmFja0J5O1xyXG4gIH1cclxuXHJcbiAgQElucHV0KClcclxuICBzZXQgaW5maW5pdGVTY3JvbGxUZW1wbGF0ZSh2YWx1ZTogVGVtcGxhdGVSZWY8TmdGb3JPZkNvbnRleHQ8VD4+KSB7XHJcbiAgICB0aGlzLl9uZ0Zvci5uZ0ZvclRlbXBsYXRlID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICBASW5wdXQoKVxyXG4gIHNldCBpbmZpbml0ZVNjcm9sbFBvc2l0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbiA9PT0gbnVsbCkge1xyXG4gICAgICB0aGlzLnBvc2l0aW9uID0gREVGQVVMVFMuUE9TSVRJT047XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICB9XHJcbiAgICB0aGlzLl9wb3NpdGlvbkluaXRpYWwgPSBwb3NpdGlvbjtcclxuICB9XHJcbiAgQElucHV0KCdpbmZpbml0ZVNjcm9sbFN0ZXAnKSBzdGVwID0gREVGQVVMVFMuU1RFUDtcclxuICBASW5wdXQoJ2luZmluaXRlU2Nyb2xsT2Zmc2V0Jykgb2Zmc2V0ID0gREVGQVVMVFMuT0ZGU0VUO1xyXG4gIEBJbnB1dCgnaW5maW5pdGVTY3JvbGxEZWxheScpIGRlbGF5ID0gREVGQVVMVFMuREVMQVk7XHJcbiAgQElucHV0KClcclxuICBzZXQgaW5maW5pdGVTY3JvbGxMb2FkaW5nKGxvYWRpbmc6IChsb2FkaW5nOiBib29sZWFuKSA9PiB2b2lkKSB7XHJcbiAgICB0aGlzLnN1YnNjcmliZUxvYWRpbmcobG9hZGluZyk7XHJcbiAgfVxyXG4gIEBJbnB1dCgpXHJcbiAgc2V0IGluZmluaXRlU2Nyb2xsRW5kKHNjcm9sbEVuZDogKHBvc2l0aW9uOiBudW1iZXIsIGludGVydmFsOiBudW1iZXIpID0+IE9ic2VydmFibGU8TmdJdGVyYWJsZTxUPj4pIHtcclxuICAgIHRoaXMuc3Vic2NyaWJlRW5kKHNjcm9sbEVuZCk7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgdXBkYXRlKCkge1xyXG4gICAgaWYgKCF0aGlzLl9pdGVtcykge1xyXG4gICAgICB0aGlzLl9pdGVtcyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9pdGVtcyAmJiAoIXRoaXMuX2l0ZW1zLmxlbmd0aCB8fCB0aGlzLl9pdGVtcy5ldmVyeSgoaXRlbSkgPT4gaXRlbSA9PT0gdW5kZWZpbmVkKSkpIHtcclxuICAgICAgdGhpcy5faXRlbXMgPSBbXTtcclxuICAgICAgdGhpcy5hZGREdW1taWVzKCk7XHJcbiAgICAgIHRoaXMudXBkYXRlSXRlbXMoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5wb3NpdGlvbiA8IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIHRoaXMuX2R1bW1pZXMpIHtcclxuICAgICAgdGhpcy5sb2FkaW5nJC5uZXh0KHRydWUpO1xyXG4gICAgICB0aGlzLnVwZGF0ZUl0ZW1zKCk7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZUFmdGVyUmVuZGVyJC5uZXh0KCk7XHJcbiAgICAgIHRoaXMucG9zaXRpb24gKz0gdGhpcy5zdGVwO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9zdWJzY3JpcHRpb25FbmQpIHtcclxuICAgICAgdGhpcy5sb2FkaW5nJC5uZXh0KHRydWUpO1xyXG4gICAgICB0aGlzLl9lbmQkLm5leHQoKTtcclxuICAgICAgdGhpcy5wb3NpdGlvbiArPSB0aGlzLnN0ZXA7XHJcbiAgICAgIHRoaXMuYWRkRHVtbWllcygpO1xyXG4gICAgICB0aGlzLnVwZGF0ZUl0ZW1zKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgbmV3SXRlbXMobmV3SXRlbXM6IE5nSXRlcmFibGU8VD4pIHtcclxuICAgIHdoaWxlICh0aGlzLl9kdW1taWVzID4gMCkge1xyXG4gICAgICBpZiAodGhpcy5faXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5faXRlbXMucG9wKCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fZHVtbWllcy0tO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmV3SXRlbXNBcnJheSA9IEFycmF5LmZyb20obmV3SXRlbXMpO1xyXG4gICAgdGhpcy5faXRlbXMgPSB0aGlzLl9pdGVtcy5jb25jYXQobmV3SXRlbXNBcnJheSk7XHJcbiAgICB0aGlzLnVwZGF0ZUl0ZW1zKCk7XHJcbiAgICAvLyBvbmx5IGNvbnRpbnVlIHdoZW4gbmV3SXRlbXMgYXJyaXZlXHJcbiAgICBpZiAobmV3SXRlbXNBcnJheS5sZW5ndGgpIHtcclxuICAgICAgdGhpcy5fdXBkYXRlQWZ0ZXJSZW5kZXIkLm5leHQoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX291dE9mSXRlbXMgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIHByaXZhdGUgdXBkYXRlSXRlbXMoKSB7XHJcbiAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcclxuICAgICAgaWYgKHRoaXMuX2l0ZW1zKSB7XHJcbiAgICAgICAgLy8gdXBkYXRlIG5nRm9yT2Y8VD4gZGlyZWN0aXZlXHJcbiAgICAgICAgdGhpcy5fbmdGb3IubmdGb3JPZiA9IHRoaXMuX2l0ZW1zLnNsaWNlKDAsIHRoaXMucG9zaXRpb24pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYWRkRHVtbWllcygpIHtcclxuICAgIGlmICghdGhpcy5fZHVtbWllcyAmJiAhdGhpcy5fb3V0T2ZJdGVtcykge1xyXG4gICAgICB0aGlzLl9pdGVtcyA9IHRoaXMuX2l0ZW1zLmNvbmNhdChBcnJheSh0aGlzLnN0ZXApLmZpbGwodW5kZWZpbmVkKSk7XHJcbiAgICAgIHRoaXMuX2R1bW1pZXMgKz0gdGhpcy5zdGVwO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbXBvcnQge0luZmluaXRlU2Nyb2xsQ29tcG9uZW50LCBJbmZpbml0ZVN0YXRpY01hcmtlciwgSW5maW5pdGVUZW1wbGF0ZU1hcmtlcn0gZnJvbSAnLi9pbmZpbml0ZS1zY3JvbGwuY29tcG9uZW50JztcclxuaW1wb3J0IHtJbmZpbml0ZVNjcm9sbERpcmVjdGl2ZX0gZnJvbSAnLi9pbmZpbml0ZS1zY3JvbGwuZGlyZWN0aXZlJztcclxuXHJcbkBOZ01vZHVsZSh7XHJcbiAgZGVjbGFyYXRpb25zOiBbSW5maW5pdGVTY3JvbGxEaXJlY3RpdmUsIEluZmluaXRlU2Nyb2xsQ29tcG9uZW50LCBJbmZpbml0ZVN0YXRpY01hcmtlciwgSW5maW5pdGVUZW1wbGF0ZU1hcmtlcl0sXHJcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXHJcbiAgZXhwb3J0czogW0luZmluaXRlU2Nyb2xsRGlyZWN0aXZlLCBJbmZpbml0ZVNjcm9sbENvbXBvbmVudCwgSW5maW5pdGVTdGF0aWNNYXJrZXIsIEluZmluaXRlVGVtcGxhdGVNYXJrZXJdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBJbmZpbml0ZVNjcm9sbE1vZHVsZSB7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxNQUFhLFFBQVEsR0FBRztJQUN0QixJQUFJLEVBQUUsQ0FBQztJQUNQLFFBQVEsRUFBRSxDQUFDO0lBQ1gsTUFBTSxFQUFFLEdBQUc7SUFDWCxLQUFLLEVBQUUsQ0FBQztDQUNULENBQUM7Ozs7OztBQ0xGOzs7O0FBT0E7Ozs7O0lBYUUsWUFBb0IsUUFBeUIsRUFBUyxJQUFZO1FBQTlDLGFBQVEsR0FBUixRQUFRLENBQWlCO1FBQVMsU0FBSSxHQUFKLElBQUksQ0FBUTt5QkFWOUMsSUFBSSxVQUFVLEVBQWlCO3FCQUtqQyxJQUFJLE9BQU8sRUFBaUI7bUNBQ2QsSUFBSSxPQUFPLEVBQU87d0JBV3ZDLFFBQVEsQ0FBQyxRQUFRO29CQUNyQixRQUFRLENBQUMsSUFBSTtzQkFDWCxRQUFRLENBQUMsTUFBTTtxQkFDaEIsUUFBUSxDQUFDLEtBQUs7d0JBQ1gsSUFBSSxlQUFlLENBQVUsS0FBSyxDQUFDO1FBVjVDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQztZQUNyQixNQUFNLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLE1BQU0sSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7WUFDeEQsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxNQUFNLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1NBQ3pELENBQUMsQ0FBQztLQUNKOzs7O0lBUUQsUUFBUTtRQUNOLElBQUksQ0FBQyx1QkFBdUIsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxJ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