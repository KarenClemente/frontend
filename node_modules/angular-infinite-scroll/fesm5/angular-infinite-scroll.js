import { NgForOf, CommonModule } from '@angular/common';
import { BehaviorSubject, interval, merge, Observable, Subject } from 'rxjs';
import { exhaustMap, switchMap, take } from 'rxjs/operators';
import { __extends } from 'tslib';
import { Component, Input, IterableDiffers, NgZone, ViewChild, ViewContainerRef, ContentChild, ContentChildren, Directive, TemplateRef, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULTS = {
    STEP: 4,
    POSITION: 0,
    OFFSET: 100,
    DELAY: 0
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template T
 */
var  /**
 * @abstract
 * @template T
 */
InfiniteScroll = /** @class */ (function () {
    function InfiniteScroll(_differs, zone) {
        var _this = this;
        this._differs = _differs;
        this.zone = zone;
        this._userEnd$ = new Observable();
        this._end$ = new Subject();
        this._updateAfterRender$ = new Subject();
        this.position = DEFAULTS.POSITION;
        this.step = DEFAULTS.STEP;
        this.offset = DEFAULTS.OFFSET;
        this.delay = DEFAULTS.DELAY;
        this.loading$ = new BehaviorSubject(false);
        zone.runOutsideAngular(function () {
            window.addEventListener('scroll', function () { return _this._update(); });
            window.addEventListener('resize', function () { return _this._update(); });
        });
    }
    /**
     * @return {?}
     */
    InfiniteScroll.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._subscriptionLoadingEnd = merge(this._userEnd$, this._updateAfterRender$).subscribe(function () { return _this.loading$.next(false); });
        this._subscriptionUpdateAfterRender =
            this._updateAfterRender$.pipe(switchMap(function () { return interval(_this.delay).pipe(take(1)); })).subscribe(function () { return _this._update(); });
        this._update();
    };
    /**
     * @return {?}
     */
    InfiniteScroll.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        if (this._ngFor) {
            this._ngFor.ngDoCheck();
        }
    };
    /**
     * @return {?}
     */
    InfiniteScroll.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroy(this._subscriptionEnd);
        this.destroy(this._subscriptionLoading);
        this.destroy(this._subscriptionLoadingEnd);
        this.destroy(this._subscriptionUpdateAfterRender);
    };
    /**
     * @param {?} viewContainer
     * @param {?} template
     * @return {?}
     */
    InfiniteScroll.prototype.createNgFor = /**
     * @param {?} viewContainer
     * @param {?} template
     * @return {?}
     */
    function (viewContainer, template) {
        this._ngFor = new NgForOf(viewContainer, template, this._differs);
    };
    /**
     * @param {?} loading
     * @return {?}
     */
    InfiniteScroll.prototype.subscribeLoading = /**
     * @param {?} loading
     * @return {?}
     */
    function (loading) {
        this.destroy(this._subscriptionLoading);
        this._subscriptionLoading = this.loading$.subscribe(loading);
    };
    /**
     * @param {?} scrollEnd
     * @return {?}
     */
    InfiniteScroll.prototype.subscribeEnd = /**
     * @param {?} scrollEnd
     * @return {?}
     */
    function (scrollEnd) {
        var _this = this;
        this.destroy(this._subscriptionEnd);
        this._userEnd$ = this._end$.pipe(exhaustMap(function () { return scrollEnd(_this.position, _this.step); }));
        this._subscriptionEnd = this._userEnd$.subscribe(this.newItems.bind(this), function () { return _this.newItems.bind(_this)([]); });
    };
    /**
     * @return {?}
     */
    InfiniteScroll.prototype._update = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var scrollHeight = window.innerHeight + window.scrollY;
        if (scrollHeight >= document.body.offsetHeight - this.offset) {
            this.zone.runOutsideAngular(function () {
                _this.update();
            });
        }
    };
    /**
     * @param {?} subscription
     * @return {?}
     */
    InfiniteScroll.prototype.destroy = /**
     * @param {?} subscription
     * @return {?}
     */
    function (subscription) {
        if (subscription && !subscription.closed) {
            subscription.unsubscribe();
        }
    };
    return InfiniteScroll;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var InfiniteStaticMarker = /** @class */ (function () {
    function InfiniteStaticMarker(template) {
        this.template = template;
        this.enabled = false;
    }
    InfiniteStaticMarker.decorators = [
        { type: Directive, args: [{ selector: '[infiniteStatic]' },] },
    ];
    /** @nocollapse */
    InfiniteStaticMarker.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return InfiniteStaticMarker;
}());
/**
 * @template T
 */
var InfiniteTemplateMarker = /** @class */ (function () {
    function InfiniteTemplateMarker(template) {
        this.template = template;
    }
    InfiniteTemplateMarker.decorators = [
        { type: Directive, args: [{ selector: '[infiniteTemplate]' },] },
    ];
    /** @nocollapse */
    InfiniteTemplateMarker.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return InfiniteTemplateMarker;
}());
/**
 * @template T
 */
var InfiniteScrollComponent = /** @class */ (function (_super) {
    __extends(InfiniteScrollComponent, _super);
    function InfiniteScrollComponent(differs, zone) {
        var _this = _super.call(this, differs, zone) || this;
        _this._dummies = 0;
        _this._outOfItems = false;
        return _this;
    }
    Object.defineProperty(InfiniteScrollComponent.prototype, "loading", {
        set: /**
         * @param {?} loading
         * @return {?}
         */
        function (loading) {
            this.subscribeLoading(loading);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InfiniteScrollComponent.prototype, "end", {
        set: /**
         * @param {?} scrollEnd
         * @return {?}
         */
        function (scrollEnd) {
            this.subscribeEnd(scrollEnd);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    InfiniteScrollComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this._itemsStatic = this.staticMarkers.toArray();
        this.updateItems();
        this.update();
    };
    /**
     * @return {?}
     */
    InfiniteScrollComponent.prototype.update = /**
     * @return {?}
     */
    function () {
        if (!this._items) {
            this._items = [];
            this._dummies = 0;
        }
        if (this._items && (!this._items.length || this._items.every(function (item) { return item === undefined; }))) {
            this._items = [];
            this._dummies = 0;
            this.addDummies();
        }
        /** @type {?} */
        var staticLength = 0;
        if (this._itemsStatic) {
            staticLength = this._itemsStatic.length;
        }
        if (this.position < staticLength) {
            this.loading$.next(true);
            this._updateAfterRender$.next();
            this.updateItems();
            this.position += this.step;
        }
        else if (staticLength + this.position < this._items.length - this._dummies) {
            this.loading$.next(true);
            this._updateAfterRender$.next();
            this.position += this.step;
        }
        else if (this._subscriptionEnd) {
            this.loading$.next(true);
            this._end$.next();
            this.addDummies();
            this.position += this.step;
        }
    };
    /**
     * @param {?} newItems
     * @return {?}
     */
    InfiniteScrollComponent.prototype.newItems = /**
     * @param {?} newItems
     * @return {?}
     */
    function (newItems) {
        var _this = this;
        while (this._dummies > 0) {
            if (this._items.length) {
                this._items.pop();
            }
            this._dummies--;
        }
        /** @type {?} */
        var newItemsArray = Array.from(newItems);
        this.zone.run(function () {
            _this._items = _this._items.concat(newItemsArray);
        });
        // only continue when newItems arrive
        if (newItemsArray.length) {
            this._updateAfterRender$.next();
        }
        else {
            this._outOfItems = true;
        }
    };
    /**
     * @return {?}
     */
    InfiniteScrollComponent.prototype.updateItems = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.zone.run(function () {
            for (var index in _this._itemsStatic) {
                _this._itemsStatic[index].enabled = _this.position > index;
            }
        });
    };
    /**
     * @return {?}
     */
    InfiniteScrollComponent.prototype.addDummies = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.zone.run(function () {
            if (!_this._dummies && !_this._outOfItems) {
                _this._items = _this._items.concat(Array(_this.step).fill(undefined));
                _this._dummies += _this.step;
            }
        });
    };
    InfiniteScrollComponent.decorators = [
        { type: Component, args: [{
                    selector: 'infinite-scroll',
                    template: "\n    <ng-template ngFor let-item [ngForOf]=\"_itemsStatic\">\n      <ng-template [ngIf]=\"item.enabled\">\n        <ng-container *ngTemplateOutlet=\"item.template\"></ng-container>\n      </ng-template>\n    </ng-template>\n    <ng-template ngFor let-item [ngForOf]=\"_items\">\n      <ng-container *ngTemplateOutlet=\"templateMarker.template; context: {$implicit: item}\"></ng-container>\n    </ng-template>"
                },] },
    ];
    /** @nocollapse */
    InfiniteScrollComponent.ctorParameters = function () { return [
        { type: IterableDiffers },
        { type: NgZone }
    ]; };
    InfiniteScrollComponent.propDecorators = {
        staticMarkers: [{ type: ContentChildren, args: [InfiniteStaticMarker,] }],
        templateMarker: [{ type: ContentChild, args: [InfiniteTemplateMarker,] }],
        dynamicTemplate: [{ type: ViewChild, args: ['dynamic',] }],
        position: [{ type: Input }],
        step: [{ type: Input }],
        offset: [{ type: Input }],
        delay: [{ type: Input }],
        loading: [{ type: Input }],
        end: [{ type: Input }]
    };
    return InfiniteScrollComponent;
}(InfiniteScroll));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var InfiniteScrollDirective = /** @class */ (function (_super) {
    __extends(InfiniteScrollDirective, _super);
    function InfiniteScrollDirective(viewContainer, templateRef, differs, zone) {
        var _this = _super.call(this, differs, zone) || this;
        _this._positionInitial = DEFAULTS.POSITION;
        _this._dummies = 0;
        _this._outOfItems = false;
        _this.step = DEFAULTS.STEP;
        _this.offset = DEFAULTS.OFFSET;
        _this.delay = DEFAULTS.DELAY;
        _this.createNgFor(viewContainer, templateRef);
        return _this;
    }
    Object.defineProperty(InfiniteScrollDirective.prototype, "infiniteScrollOf", {
        set: /**
         * @param {?} infiniteScrollOf
         * @return {?}
         */
        function (infiniteScrollOf) {
            if (infiniteScrollOf) {
                this._items = Array.from(infiniteScrollOf);
            }
            this.position = this._positionInitial;
            this._dummies = 0;
            this.updateItems();
            this.update();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InfiniteScrollDirective.prototype, "infiniteScrollTrackBy", {
        get: /**
         * @return {?}
         */
        function () {
            return this._ngFor.ngForTrackBy;
        },
        set: /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._ngFor.ngForTrackBy = fn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InfiniteScrollDirective.prototype, "infiniteScrollTemplate", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._ngFor.ngForTemplate = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InfiniteScrollDirective.prototype, "infiniteScrollPosition", {
        set: /**
         * @param {?} position
         * @return {?}
         */
        function (position) {
            if (position === undefined || position === null) {
                this.position = DEFAULTS.POSITION;
            }
            else {
                this.position = position;
            }
            this._positionInitial = position;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InfiniteScrollDirective.prototype, "infiniteScrollLoading", {
        set: /**
         * @param {?} loading
         * @return {?}
         */
        function (loading) {
            this.subscribeLoading(loading);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InfiniteScrollDirective.prototype, "infiniteScrollEnd", {
        set: /**
         * @param {?} scrollEnd
         * @return {?}
         */
        function (scrollEnd) {
            this.subscribeEnd(scrollEnd);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    InfiniteScrollDirective.prototype.update = /**
     * @return {?}
     */
    function () {
        if (!this._items) {
            this._items = [];
        }
        if (this._items && (!this._items.length || this._items.every(function (item) { return item === undefined; }))) {
            this._items = [];
            this.addDummies();
            this.updateItems();
        }
        if (this.position < this._items.length - this._dummies) {
            this.loading$.next(true);
            this.updateItems();
            this._updateAfterRender$.next();
            this.position += this.step;
        }
        else if (this._subscriptionEnd) {
            this.loading$.next(true);
            this._end$.next();
            this.position += this.step;
            this.addDummies();
            this.updateItems();
        }
    };
    /**
     * @param {?} newItems
     * @return {?}
     */
    InfiniteScrollDirective.prototype.newItems = /**
     * @param {?} newItems
     * @return {?}
     */
    function (newItems) {
        while (this._dummies > 0) {
            if (this._items.length) {
                this._items.pop();
            }
            this._dummies--;
        }
        /** @type {?} */
        var newItemsArray = Array.from(newItems);
        this._items = this._items.concat(newItemsArray);
        this.updateItems();
        // only continue when newItems arrive
        if (newItemsArray.length) {
            this._updateAfterRender$.next();
        }
        else {
            this._outOfItems = true;
        }
    };
    /**
     * @return {?}
     */
    InfiniteScrollDirective.prototype.updateItems = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.zone.run(function () {
            if (_this._items) {
                // update ngForOf<T> directive
                // update ngForOf<T> directive
                _this._ngFor.ngForOf = _this._items.slice(0, _this.position);
            }
        });
    };
    /**
     * @return {?}
     */
    InfiniteScrollDirective.prototype.addDummies = /**
     * @return {?}
     */
    function () {
        if (!this._dummies && !this._outOfItems) {
            this._items = this._items.concat(Array(this.step).fill(undefined));
            this._dummies += this.step;
        }
    };
    InfiniteScrollDirective.decorators = [
        { type: Directive, args: [{ selector: '[infiniteScroll]' },] },
    ];
    /** @nocollapse */
    InfiniteScrollDirective.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: TemplateRef },
        { type: IterableDiffers },
        { type: NgZone }
    ]; };
    InfiniteScrollDirective.propDecorators = {
        infiniteScrollOf: [{ type: Input }],
        infiniteScrollTrackBy: [{ type: Input }],
        infiniteScrollTemplate: [{ type: Input }],
        infiniteScrollPosition: [{ type: Input }],
        step: [{ type: Input, args: ['infiniteScrollStep',] }],
        offset: [{ type: Input, args: ['infiniteScrollOffset',] }],
        delay: [{ type: Input, args: ['infiniteScrollDelay',] }],
        infiniteScrollLoading: [{ type: Input }],
        infiniteScrollEnd: [{ type: Input }]
    };
    return InfiniteScrollDirective;
}(InfiniteScroll));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var InfiniteScrollModule = /** @class */ (function () {
    function InfiniteScrollModule() {
    }
    InfiniteScrollModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [InfiniteScrollDirective, InfiniteScrollComponent, InfiniteStaticMarker, InfiniteTemplateMarker],
                    imports: [CommonModule],
                    exports: [InfiniteScrollDirective, InfiniteScrollComponent, InfiniteStaticMarker, InfiniteTemplateMarker]
                },] },
    ];
    return InfiniteScrollModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { InfiniteScrollModule, InfiniteScroll as ɵb, InfiniteScrollComponent as ɵe, InfiniteStaticMarker as ɵc, InfiniteTemplateMarker as ɵd, InfiniteScrollDirective as ɵa };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1pbmZpbml0ZS1zY3JvbGwuanMubWFwIiwic291cmNlcyI6WyJuZzovL2FuZ3VsYXItaW5maW5pdGUtc2Nyb2xsL2xpYi9kZWZhdWx0cy50cyIsIm5nOi8vYW5ndWxhci1pbmZpbml0ZS1zY3JvbGwvbGliL2luZmluaXRlLXNjcm9sbC50cyIsIm5nOi8vYW5ndWxhci1pbmZpbml0ZS1zY3JvbGwvbGliL2luZmluaXRlLXNjcm9sbC5jb21wb25lbnQudHMiLCJuZzovL2FuZ3VsYXItaW5maW5pdGUtc2Nyb2xsL2xpYi9pbmZpbml0ZS1zY3JvbGwuZGlyZWN0aXZlLnRzIiwibmc6Ly9hbmd1bGFyLWluZmluaXRlLXNjcm9sbC9saWIvaW5maW5pdGUtc2Nyb2xsLm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgREVGQVVMVFMgPSB7XHJcbiAgU1RFUDogNCxcclxuICBQT1NJVElPTjogMCxcclxuICBPRkZTRVQ6IDEwMCxcclxuICBERUxBWTogMFxyXG59OyIsImltcG9ydCB7TmdGb3JPZiwgTmdGb3JPZkNvbnRleHR9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7RG9DaGVjaywgSXRlcmFibGVEaWZmZXJzLCBOZ0l0ZXJhYmxlLCBOZ1pvbmUsIE9uRGVzdHJveSwgT25Jbml0LCBUZW1wbGF0ZVJlZiwgVmlld0NvbnRhaW5lclJlZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7QmVoYXZpb3JTdWJqZWN0LCBpbnRlcnZhbCwgbWVyZ2UsIE9ic2VydmFibGUsIFN1YmplY3QsIFN1YnNjcmlwdGlvbn0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7ZXhoYXVzdE1hcCwgc3dpdGNoTWFwLCB0YWtlfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQge0RFRkFVTFRTfSBmcm9tICcuL2RlZmF1bHRzJztcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJbmZpbml0ZVNjcm9sbDxUPiBpbXBsZW1lbnRzIE9uSW5pdCwgRG9DaGVjaywgT25EZXN0cm95IHtcclxuICBwcml2YXRlIF9zdWJzY3JpcHRpb25Mb2FkaW5nOiBTdWJzY3JpcHRpb247XHJcbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uTG9hZGluZ0VuZDogU3Vic2NyaXB0aW9uO1xyXG4gIHByaXZhdGUgX3VzZXJFbmQkID0gbmV3IE9ic2VydmFibGU8TmdJdGVyYWJsZTxUPj4oKTtcclxuXHJcbiAgcHJvdGVjdGVkIF9zdWJzY3JpcHRpb25FbmQ6IFN1YnNjcmlwdGlvbjtcclxuICBwcm90ZWN0ZWQgX3N1YnNjcmlwdGlvblVwZGF0ZUFmdGVyUmVuZGVyOiBTdWJzY3JpcHRpb247XHJcblxyXG4gIHByb3RlY3RlZCBfZW5kJCA9IG5ldyBTdWJqZWN0PE5nSXRlcmFibGU8VD4+KCk7XHJcbiAgcHJvdGVjdGVkIF91cGRhdGVBZnRlclJlbmRlciQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XHJcblxyXG4gIHByb3RlY3RlZCBfbmdGb3I7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2RpZmZlcnM6IEl0ZXJhYmxlRGlmZmVycywgcHVibGljIHpvbmU6IE5nWm9uZSkge1xyXG4gICAgem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCAoKSA9PiB0aGlzLl91cGRhdGUoKSk7XHJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKSA9PiB0aGlzLl91cGRhdGUoKSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHBvc2l0aW9uID0gREVGQVVMVFMuUE9TSVRJT047XHJcbiAgc3RlcCA9IERFRkFVTFRTLlNURVA7XHJcbiAgb2Zmc2V0ID0gREVGQVVMVFMuT0ZGU0VUO1xyXG4gIGRlbGF5ID0gREVGQVVMVFMuREVMQVk7XHJcbiAgbG9hZGluZyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcclxuXHJcbiAgbmdPbkluaXQoKSB7XHJcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25Mb2FkaW5nRW5kID0gbWVyZ2UodGhpcy5fdXNlckVuZCQsIHRoaXMuX3VwZGF0ZUFmdGVyUmVuZGVyJCkuc3Vic2NyaWJlKCgpID0+IHRoaXMubG9hZGluZyQubmV4dChmYWxzZSkpO1xyXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uVXBkYXRlQWZ0ZXJSZW5kZXIgPVxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUFmdGVyUmVuZGVyJC5waXBlKHN3aXRjaE1hcCgoKSA9PiBpbnRlcnZhbCh0aGlzLmRlbGF5KS5waXBlKHRha2UoMSkpKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3VwZGF0ZSgpKTtcclxuXHJcbiAgICB0aGlzLl91cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIG5nRG9DaGVjaygpIHtcclxuICAgIGlmICh0aGlzLl9uZ0Zvcikge1xyXG4gICAgICB0aGlzLl9uZ0Zvci5uZ0RvQ2hlY2soKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCkge1xyXG4gICAgdGhpcy5kZXN0cm95KHRoaXMuX3N1YnNjcmlwdGlvbkVuZCk7XHJcbiAgICB0aGlzLmRlc3Ryb3kodGhpcy5fc3Vic2NyaXB0aW9uTG9hZGluZyk7XHJcbiAgICB0aGlzLmRlc3Ryb3kodGhpcy5fc3Vic2NyaXB0aW9uTG9hZGluZ0VuZCk7XHJcbiAgICB0aGlzLmRlc3Ryb3kodGhpcy5fc3Vic2NyaXB0aW9uVXBkYXRlQWZ0ZXJSZW5kZXIpO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIGNyZWF0ZU5nRm9yKHZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxOZ0Zvck9mQ29udGV4dDxUPj4pIHtcclxuICAgIHRoaXMuX25nRm9yID0gbmV3IE5nRm9yT2Y8VD4odmlld0NvbnRhaW5lciwgdGVtcGxhdGUsIHRoaXMuX2RpZmZlcnMpO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIHN1YnNjcmliZUxvYWRpbmcobG9hZGluZzogKGxvYWRpbmc6IGJvb2xlYW4pID0+IHZvaWQpIHtcclxuICAgIHRoaXMuZGVzdHJveSh0aGlzLl9zdWJzY3JpcHRpb25Mb2FkaW5nKTtcclxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkxvYWRpbmcgPSB0aGlzLmxvYWRpbmckLnN1YnNjcmliZShsb2FkaW5nKTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBzdWJzY3JpYmVFbmQoc2Nyb2xsRW5kOiAocG9zaXRpb246IG51bWJlciwgaW50ZXJ2YWw6IG51bWJlcikgPT4gT2JzZXJ2YWJsZTxOZ0l0ZXJhYmxlPFQ+Pikge1xyXG4gICAgdGhpcy5kZXN0cm95KHRoaXMuX3N1YnNjcmlwdGlvbkVuZCk7XHJcbiAgICB0aGlzLl91c2VyRW5kJCA9IHRoaXMuX2VuZCQucGlwZShleGhhdXN0TWFwKCgpID0+IHNjcm9sbEVuZCh0aGlzLnBvc2l0aW9uLCB0aGlzLnN0ZXApKSk7XHJcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25FbmQgPSB0aGlzLl91c2VyRW5kJC5zdWJzY3JpYmUodGhpcy5uZXdJdGVtcy5iaW5kKHRoaXMpLCAoKSA9PiB0aGlzLm5ld0l0ZW1zLmJpbmQodGhpcykoW10pKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX3VwZGF0ZSgpIHtcclxuICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCArIHdpbmRvdy5zY3JvbGxZO1xyXG4gICAgaWYgKHNjcm9sbEhlaWdodCA+PSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodCAtIHRoaXMub2Zmc2V0KSB7XHJcbiAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGRlc3Ryb3koc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24pIHtcclxuICAgIGlmIChzdWJzY3JpcHRpb24gJiYgIXN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcclxuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgdXBkYXRlKCk7XHJcblxyXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBuZXdJdGVtcyhuZXdJdGVtczogTmdJdGVyYWJsZTxUPik7XHJcbn1cclxuIiwiaW1wb3J0IHtOZ0Zvck9mQ29udGV4dH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHtBZnRlckNvbnRlbnRJbml0LCBDb21wb25lbnQsIElucHV0LCBJdGVyYWJsZURpZmZlcnMsIE5nSXRlcmFibGUsIE5nWm9uZSwgVmlld0NoaWxkLCBWaWV3Q29udGFpbmVyUmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHtDb250ZW50Q2hpbGQsIENvbnRlbnRDaGlsZHJlbiwgRGlyZWN0aXZlLCBRdWVyeUxpc3QsIFRlbXBsYXRlUmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzJztcclxuXHJcbmltcG9ydCB7SW5maW5pdGVTY3JvbGx9IGZyb20gJy4vaW5maW5pdGUtc2Nyb2xsJztcclxuXHJcbkBEaXJlY3RpdmUoe3NlbGVjdG9yOiAnW2luZmluaXRlU3RhdGljXSd9KVxyXG5leHBvcnQgY2xhc3MgSW5maW5pdGVTdGF0aWNNYXJrZXI8VD4ge1xyXG4gIHB1YmxpYyBlbmFibGVkID0gZmFsc2U7XHJcbiAgY29uc3RydWN0b3IocHVibGljIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxUPikge31cclxufVxyXG5cclxuQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdbaW5maW5pdGVUZW1wbGF0ZV0nfSlcclxuZXhwb3J0IGNsYXNzIEluZmluaXRlVGVtcGxhdGVNYXJrZXI8VD4ge1xyXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8TmdGb3JPZkNvbnRleHQ8VD4+KSB7fVxyXG59XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ2luZmluaXRlLXNjcm9sbCcsXHJcbiAgdGVtcGxhdGU6IGBcclxuICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtaXRlbSBbbmdGb3JPZl09XCJfaXRlbXNTdGF0aWNcIj5cclxuICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIml0ZW0uZW5hYmxlZFwiPlxyXG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJpdGVtLnRlbXBsYXRlXCI+PC9uZy1jb250YWluZXI+XHJcbiAgICAgIDwvbmctdGVtcGxhdGU+XHJcbiAgICA8L25nLXRlbXBsYXRlPlxyXG4gICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1pdGVtIFtuZ0Zvck9mXT1cIl9pdGVtc1wiPlxyXG4gICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwidGVtcGxhdGVNYXJrZXIudGVtcGxhdGU7IGNvbnRleHQ6IHskaW1wbGljaXQ6IGl0ZW19XCI+PC9uZy1jb250YWluZXI+XHJcbiAgICA8L25nLXRlbXBsYXRlPmBcclxufSlcclxuZXhwb3J0IGNsYXNzIEluZmluaXRlU2Nyb2xsQ29tcG9uZW50PFQ+IGV4dGVuZHMgSW5maW5pdGVTY3JvbGw8VD4gaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcclxuICBAQ29udGVudENoaWxkcmVuKEluZmluaXRlU3RhdGljTWFya2VyKSBzdGF0aWNNYXJrZXJzOiBRdWVyeUxpc3Q8SW5maW5pdGVTdGF0aWNNYXJrZXI8VD4+O1xyXG4gIEBDb250ZW50Q2hpbGQoSW5maW5pdGVUZW1wbGF0ZU1hcmtlcikgdGVtcGxhdGVNYXJrZXI6IEluZmluaXRlVGVtcGxhdGVNYXJrZXI8VD47XHJcbiAgQFZpZXdDaGlsZCgnZHluYW1pYycpIGR5bmFtaWNUZW1wbGF0ZTogVmlld0NvbnRhaW5lclJlZjtcclxuXHJcbiAgX2l0ZW1zU3RhdGljOiBBcnJheTxJbmZpbml0ZVN0YXRpY01hcmtlcjxUPj47XHJcbiAgX2l0ZW1zOiBBcnJheTxUPjtcclxuXHJcbiAgcHJpdmF0ZSBfZHVtbWllcyA9IDA7XHJcbiAgcHJpdmF0ZSBfb3V0T2ZJdGVtcyA9IGZhbHNlO1xyXG5cclxuICBjb25zdHJ1Y3RvcihkaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMsIHpvbmU6IE5nWm9uZSkge1xyXG4gICAgc3VwZXIoZGlmZmVycywgem9uZSk7XHJcbiAgfVxyXG5cclxuICBASW5wdXQoKSBwb3NpdGlvbjtcclxuICBASW5wdXQoKSBzdGVwO1xyXG4gIEBJbnB1dCgpIG9mZnNldDtcclxuICBASW5wdXQoKSBkZWxheTtcclxuICBASW5wdXQoKVxyXG4gIHNldCBsb2FkaW5nKGxvYWRpbmc6IChsb2FkaW5nOiBib29sZWFuKSA9PiB2b2lkKSB7XHJcbiAgICB0aGlzLnN1YnNjcmliZUxvYWRpbmcobG9hZGluZyk7XHJcbiAgfVxyXG4gIEBJbnB1dCgpXHJcbiAgc2V0IGVuZChzY3JvbGxFbmQ6IChwb3NpdGlvbjogbnVtYmVyLCBpbnRlcnZhbDogbnVtYmVyKSA9PiBPYnNlcnZhYmxlPE5nSXRlcmFibGU8VD4+KSB7XHJcbiAgICB0aGlzLnN1YnNjcmliZUVuZChzY3JvbGxFbmQpO1xyXG4gIH1cclxuXHJcbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xyXG4gICAgdGhpcy5faXRlbXNTdGF0aWMgPSB0aGlzLnN0YXRpY01hcmtlcnMudG9BcnJheSgpO1xyXG4gICAgdGhpcy51cGRhdGVJdGVtcygpO1xyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCB1cGRhdGUoKSB7XHJcbiAgICBpZiAoIXRoaXMuX2l0ZW1zKSB7XHJcbiAgICAgIHRoaXMuX2l0ZW1zID0gW107XHJcbiAgICAgIHRoaXMuX2R1bW1pZXMgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9pdGVtcyAmJiAoIXRoaXMuX2l0ZW1zLmxlbmd0aCB8fCB0aGlzLl9pdGVtcy5ldmVyeSgoaXRlbSkgPT4gaXRlbSA9PT0gdW5kZWZpbmVkKSkpIHtcclxuICAgICAgdGhpcy5faXRlbXMgPSBbXTtcclxuICAgICAgdGhpcy5fZHVtbWllcyA9IDA7XHJcbiAgICAgIHRoaXMuYWRkRHVtbWllcygpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBzdGF0aWNMZW5ndGggPSAwO1xyXG4gICAgaWYgKHRoaXMuX2l0ZW1zU3RhdGljKSB7XHJcbiAgICAgIHN0YXRpY0xlbmd0aCA9IHRoaXMuX2l0ZW1zU3RhdGljLmxlbmd0aFxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLnBvc2l0aW9uIDwgc3RhdGljTGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMubG9hZGluZyQubmV4dCh0cnVlKTtcclxuICAgICAgdGhpcy5fdXBkYXRlQWZ0ZXJSZW5kZXIkLm5leHQoKTtcclxuICAgICAgdGhpcy51cGRhdGVJdGVtcygpO1xyXG4gICAgICB0aGlzLnBvc2l0aW9uICs9IHRoaXMuc3RlcDtcclxuICAgIH0gZWxzZSBpZiAoc3RhdGljTGVuZ3RoICsgdGhpcy5wb3NpdGlvbiA8IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIHRoaXMuX2R1bW1pZXMpIHtcclxuICAgICAgdGhpcy5sb2FkaW5nJC5uZXh0KHRydWUpO1xyXG4gICAgICB0aGlzLl91cGRhdGVBZnRlclJlbmRlciQubmV4dCgpO1xyXG4gICAgICB0aGlzLnBvc2l0aW9uICs9IHRoaXMuc3RlcDtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3Vic2NyaXB0aW9uRW5kKSB7XHJcbiAgICAgIHRoaXMubG9hZGluZyQubmV4dCh0cnVlKTtcclxuICAgICAgdGhpcy5fZW5kJC5uZXh0KCk7XHJcbiAgICAgIHRoaXMuYWRkRHVtbWllcygpO1xyXG4gICAgICB0aGlzLnBvc2l0aW9uICs9IHRoaXMuc3RlcDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBuZXdJdGVtcyhuZXdJdGVtczogTmdJdGVyYWJsZTxUPikge1xyXG4gICAgd2hpbGUgKHRoaXMuX2R1bW1pZXMgPiAwKSB7XHJcbiAgICAgIGlmICh0aGlzLl9pdGVtcy5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLl9pdGVtcy5wb3AoKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9kdW1taWVzLS07XHJcbiAgICB9XHJcbiAgICBjb25zdCBuZXdJdGVtc0FycmF5ID0gQXJyYXkuZnJvbShuZXdJdGVtcyk7XHJcbiAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcclxuICAgICAgdGhpcy5faXRlbXMgPSB0aGlzLl9pdGVtcy5jb25jYXQobmV3SXRlbXNBcnJheSk7XHJcbiAgICB9KTtcclxuICAgIC8vIG9ubHkgY29udGludWUgd2hlbiBuZXdJdGVtcyBhcnJpdmVcclxuICAgIGlmIChuZXdJdGVtc0FycmF5Lmxlbmd0aCkge1xyXG4gICAgICB0aGlzLl91cGRhdGVBZnRlclJlbmRlciQubmV4dCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fb3V0T2ZJdGVtcyA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHVwZGF0ZUl0ZW1zKCkge1xyXG4gICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgIGZvciAoY29uc3QgaW5kZXggaW4gdGhpcy5faXRlbXNTdGF0aWMpIHtcclxuICAgICAgICB0aGlzLl9pdGVtc1N0YXRpY1tpbmRleF0uZW5hYmxlZCA9IHRoaXMucG9zaXRpb24gPiBpbmRleDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFkZER1bW1pZXMoKSB7XHJcbiAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcclxuICAgICAgaWYgKCF0aGlzLl9kdW1taWVzICYmICF0aGlzLl9vdXRPZkl0ZW1zKSB7XHJcbiAgICAgICAgdGhpcy5faXRlbXMgPSB0aGlzLl9pdGVtcy5jb25jYXQoQXJyYXkodGhpcy5zdGVwKS5maWxsKHVuZGVmaW5lZCkpO1xyXG4gICAgICAgIHRoaXMuX2R1bW1pZXMgKz0gdGhpcy5zdGVwO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHtOZ0Zvck9mQ29udGV4dH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHtEaXJlY3RpdmUsIElucHV0LCBJdGVyYWJsZURpZmZlcnMsIE5nSXRlcmFibGUsIE9uRGVzdHJveSwgT25Jbml0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHtOZ1pvbmUsIFRlbXBsYXRlUmVmLCBUcmFja0J5RnVuY3Rpb24sIFZpZXdDb250YWluZXJSZWZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQge0RFRkFVTFRTfSBmcm9tICcuL2RlZmF1bHRzJztcclxuaW1wb3J0IHtJbmZpbml0ZVNjcm9sbH0gZnJvbSAnLi9pbmZpbml0ZS1zY3JvbGwnO1xyXG5cclxuQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdbaW5maW5pdGVTY3JvbGxdJ30pXHJcbmV4cG9ydCBjbGFzcyBJbmZpbml0ZVNjcm9sbERpcmVjdGl2ZTxUPiBleHRlbmRzIEluZmluaXRlU2Nyb2xsPFQ+IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xyXG4gIHByaXZhdGUgX2l0ZW1zOiBBcnJheTxUPjtcclxuICBwcml2YXRlIF9wb3NpdGlvbkluaXRpYWwgPSBERUZBVUxUUy5QT1NJVElPTjtcclxuXHJcbiAgcHJpdmF0ZSBfZHVtbWllcyA9IDA7XHJcbiAgcHJpdmF0ZSBfb3V0T2ZJdGVtcyA9IGZhbHNlO1xyXG5cclxuICBjb25zdHJ1Y3Rvcih2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLCB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8TmdGb3JPZkNvbnRleHQ8VD4+LCBkaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMsIHpvbmU6IE5nWm9uZSkge1xyXG4gICAgc3VwZXIoZGlmZmVycywgem9uZSk7XHJcbiAgICB0aGlzLmNyZWF0ZU5nRm9yKHZpZXdDb250YWluZXIsIHRlbXBsYXRlUmVmKTtcclxuICB9XHJcblxyXG4gIEBJbnB1dCgpXHJcbiAgc2V0IGluZmluaXRlU2Nyb2xsT2YoaW5maW5pdGVTY3JvbGxPZjogTmdJdGVyYWJsZTxUPikge1xyXG4gICAgaWYgKGluZmluaXRlU2Nyb2xsT2YpIHtcclxuICAgICAgdGhpcy5faXRlbXMgPSBBcnJheS5mcm9tKGluZmluaXRlU2Nyb2xsT2YpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uSW5pdGlhbDtcclxuICAgIHRoaXMuX2R1bW1pZXMgPSAwO1xyXG4gICAgdGhpcy51cGRhdGVJdGVtcygpO1xyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcbiAgQElucHV0KClcclxuICBzZXQgaW5maW5pdGVTY3JvbGxUcmFja0J5KGZuOiBUcmFja0J5RnVuY3Rpb248VD4pIHtcclxuICAgIHRoaXMuX25nRm9yLm5nRm9yVHJhY2tCeSA9IGZuO1xyXG4gIH1cclxuICBnZXQgaW5maW5pdGVTY3JvbGxUcmFja0J5KCk6IFRyYWNrQnlGdW5jdGlvbjxUPiB7XHJcbiAgICByZXR1cm4gdGhpcy5fbmdGb3IubmdGb3JUcmFja0J5O1xyXG4gIH1cclxuXHJcbiAgQElucHV0KClcclxuICBzZXQgaW5maW5pdGVTY3JvbGxUZW1wbGF0ZSh2YWx1ZTogVGVtcGxhdGVSZWY8TmdGb3JPZkNvbnRleHQ8VD4+KSB7XHJcbiAgICB0aGlzLl9uZ0Zvci5uZ0ZvclRlbXBsYXRlID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICBASW5wdXQoKVxyXG4gIHNldCBpbmZpbml0ZVNjcm9sbFBvc2l0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbiA9PT0gbnVsbCkge1xyXG4gICAgICB0aGlzLnBvc2l0aW9uID0gREVGQVVMVFMuUE9TSVRJT047XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICB9XHJcbiAgICB0aGlzLl9wb3NpdGlvbkluaXRpYWwgPSBwb3NpdGlvbjtcclxuICB9XHJcbiAgQElucHV0KCdpbmZpbml0ZVNjcm9sbFN0ZXAnKSBzdGVwID0gREVGQVVMVFMuU1RFUDtcclxuICBASW5wdXQoJ2luZmluaXRlU2Nyb2xsT2Zmc2V0Jykgb2Zmc2V0ID0gREVGQVVMVFMuT0ZGU0VUO1xyXG4gIEBJbnB1dCgnaW5maW5pdGVTY3JvbGxEZWxheScpIGRlbGF5ID0gREVGQVVMVFMuREVMQVk7XHJcbiAgQElucHV0KClcclxuICBzZXQgaW5maW5pdGVTY3JvbGxMb2FkaW5nKGxvYWRpbmc6IChsb2FkaW5nOiBib29sZWFuKSA9PiB2b2lkKSB7XHJcbiAgICB0aGlzLnN1YnNjcmliZUxvYWRpbmcobG9hZGluZyk7XHJcbiAgfVxyXG4gIEBJbnB1dCgpXHJcbiAgc2V0IGluZmluaXRlU2Nyb2xsRW5kKHNjcm9sbEVuZDogKHBvc2l0aW9uOiBudW1iZXIsIGludGVydmFsOiBudW1iZXIpID0+IE9ic2VydmFibGU8TmdJdGVyYWJsZTxUPj4pIHtcclxuICAgIHRoaXMuc3Vic2NyaWJlRW5kKHNjcm9sbEVuZCk7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgdXBkYXRlKCkge1xyXG4gICAgaWYgKCF0aGlzLl9pdGVtcykge1xyXG4gICAgICB0aGlzLl9pdGVtcyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9pdGVtcyAmJiAoIXRoaXMuX2l0ZW1zLmxlbmd0aCB8fCB0aGlzLl9pdGVtcy5ldmVyeSgoaXRlbSkgPT4gaXRlbSA9PT0gdW5kZWZpbmVkKSkpIHtcclxuICAgICAgdGhpcy5faXRlbXMgPSBbXTtcclxuICAgICAgdGhpcy5hZGREdW1taWVzKCk7XHJcbiAgICAgIHRoaXMudXBkYXRlSXRlbXMoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5wb3NpdGlvbiA8IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIHRoaXMuX2R1bW1pZXMpIHtcclxuICAgICAgdGhpcy5sb2FkaW5nJC5uZXh0KHRydWUpO1xyXG4gICAgICB0aGlzLnVwZGF0ZUl0ZW1zKCk7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZUFmdGVyUmVuZGVyJC5uZXh0KCk7XHJcbiAgICAgIHRoaXMucG9zaXRpb24gKz0gdGhpcy5zdGVwO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9zdWJzY3JpcHRpb25FbmQpIHtcclxuICAgICAgdGhpcy5sb2FkaW5nJC5uZXh0KHRydWUpO1xyXG4gICAgICB0aGlzLl9lbmQkLm5leHQoKTtcclxuICAgICAgdGhpcy5wb3NpdGlvbiArPSB0aGlzLnN0ZXA7XHJcbiAgICAgIHRoaXMuYWRkRHVtbWllcygpO1xyXG4gICAgICB0aGlzLnVwZGF0ZUl0ZW1zKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgbmV3SXRlbXMobmV3SXRlbXM6IE5nSXRlcmFibGU8VD4pIHtcclxuICAgIHdoaWxlICh0aGlzLl9kdW1taWVzID4gMCkge1xyXG4gICAgICBpZiAodGhpcy5faXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5faXRlbXMucG9wKCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fZHVtbWllcy0tO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmV3SXRlbXNBcnJheSA9IEFycmF5LmZyb20obmV3SXRlbXMpO1xyXG4gICAgdGhpcy5faXRlbXMgPSB0aGlzLl9pdGVtcy5jb25jYXQobmV3SXRlbXNBcnJheSk7XHJcbiAgICB0aGlzLnVwZGF0ZUl0ZW1zKCk7XHJcbiAgICAvLyBvbmx5IGNvbnRpbnVlIHdoZW4gbmV3SXRlbXMgYXJyaXZlXHJcbiAgICBpZiAobmV3SXRlbXNBcnJheS5sZW5ndGgpIHtcclxuICAgICAgdGhpcy5fdXBkYXRlQWZ0ZXJSZW5kZXIkLm5leHQoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX291dE9mSXRlbXMgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIHByaXZhdGUgdXBkYXRlSXRlbXMoKSB7XHJcbiAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcclxuICAgICAgaWYgKHRoaXMuX2l0ZW1zKSB7XHJcbiAgICAgICAgLy8gdXBkYXRlIG5nRm9yT2Y8VD4gZGlyZWN0aXZlXHJcbiAgICAgICAgdGhpcy5fbmdGb3IubmdGb3JPZiA9IHRoaXMuX2l0ZW1zLnNsaWNlKDAsIHRoaXMucG9zaXRpb24pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYWRkRHVtbWllcygpIHtcclxuICAgIGlmICghdGhpcy5fZHVtbWllcyAmJiAhdGhpcy5fb3V0T2ZJdGVtcykge1xyXG4gICAgICB0aGlzLl9pdGVtcyA9IHRoaXMuX2l0ZW1zLmNvbmNhdChBcnJheSh0aGlzLnN0ZXApLmZpbGwodW5kZWZpbmVkKSk7XHJcbiAgICAgIHRoaXMuX2R1bW1pZXMgKz0gdGhpcy5zdGVwO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbXBvcnQge0luZmluaXRlU2Nyb2xsQ29tcG9uZW50LCBJbmZpbml0ZVN0YXRpY01hcmtlciwgSW5maW5pdGVUZW1wbGF0ZU1hcmtlcn0gZnJvbSAnLi9pbmZpbml0ZS1zY3JvbGwuY29tcG9uZW50JztcclxuaW1wb3J0IHtJbmZpbml0ZVNjcm9sbERpcmVjdGl2ZX0gZnJvbSAnLi9pbmZpbml0ZS1zY3JvbGwuZGlyZWN0aXZlJztcclxuXHJcbkBOZ01vZHVsZSh7XHJcbiAgZGVjbGFyYXRpb25zOiBbSW5maW5pdGVTY3JvbGxEaXJlY3RpdmUsIEluZmluaXRlU2Nyb2xsQ29tcG9uZW50LCBJbmZpbml0ZVN0YXRpY01hcmtlciwgSW5maW5pdGVUZW1wbGF0ZU1hcmtlcl0sXHJcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXHJcbiAgZXhwb3J0czogW0luZmluaXRlU2Nyb2xsRGlyZWN0aXZlLCBJbmZpbml0ZVNjcm9sbENvbXBvbmVudCwgSW5maW5pdGVTdGF0aWNNYXJrZXIsIEluZmluaXRlVGVtcGxhdGVNYXJrZXJdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBJbmZpbml0ZVNjcm9sbE1vZHVsZSB7XHJcbn1cclxuIl0sIm5hbWVzIjpbInRzbGliXzEuX19leHRlbmRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLElBQWEsUUFBUSxHQUFHO0lBQ3RCLElBQUksRUFBRSxDQUFDO0lBQ1AsUUFBUSxFQUFFLENBQUM7SUFDWCxNQUFNLEVBQUUsR0FBRztJQUNYLEtBQUssRUFBRSxDQUFDO0NBQ1QsQ0FBQzs7Ozs7O0FDTEY7Ozs7QUFPQTs7OztBQUFBO0lBYUUsd0JBQW9CLFFBQXlCLEVBQVMsSUFBWTtRQUFsRSxpQkFLQztRQUxtQixhQUFRLEdBQVIsUUFBUSxDQUFpQjtRQUFTLFNBQUksR0FBSixJQUFJLENBQVE7eUJBVjlDLElBQUksVUFBVSxFQUFpQjtxQkFLakMsSUFBSSxPQUFPLEVBQWlCO21DQUNkLElBQUksT0FBTyxFQUFPO3dCQVd2QyxRQUFRLENBQUMsUUFBUTtvQkFDckIsUUFBUSxDQUFDLElBQUk7c0JBQ1gsUUFBUSxDQUFDLE1BQU07cUJBQ2hCLFFBQVEsQ0FBQyxLQUFLO3dCQUNYLElBQUksZUFBZSxDQUFVLEtBQUssQ0FBQztRQVY1QyxJQUFJLENBQUMsaUJBQWlCLENBQUM7WUFDckIsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxjQUFNLE9BQUEsS0FBSSxDQUFDLE9BQU8sRUFBRSxHQUFBLENBQUMsQ0FBQztZQUN4RCxNQUFNLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLGNBQU0sT0FBQSxLQUFJLENBQUMsT0FBTyxFQUFFLEdBQUEsQ0FBQyxDQUFDO1NBQ3pELENBQUMsQ0FBQztLQUNKOzs7O0lBUUQsaUNBQVE7OztJQUFSO1FBQUEsaUJBTUM7UUFMQyxJQUFJLENBQUMsdUJBQXVCLEdB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